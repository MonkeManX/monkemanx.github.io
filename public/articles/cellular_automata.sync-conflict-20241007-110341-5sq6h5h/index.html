<!DOCTYPE html>
<html>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
      <meta charset="utf-8">
      <meta name="viewport" 
          content="width=device-width, initial-scale=1.0">
      <title>My site</title>
      <link rel="stylesheet" href="/styles/style.css">  

      <link rel="stylesheet" href="/css/syntax.css">
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>

  </head>
  <body><div class="nav-div">
  <nav>
        <a href="http://localhost:1313/" class="">Home</a>
        <a href="http://localhost:1313/articles/" class="active">Articles</a>
        <a href="http://localhost:1313/paper-summary/" class="">Paper-Summaries</a>
        <a href="http://localhost:1313/tags/" class="">Tags</a>
        <a href="http://localhost:1313/poetry/" class="">Writings</a>
        <a href="http://localhost:1313/tangled_thoughts/" class="">Tangled-Thoughts</a>
        <a href="http://localhost:1313/media/" class="">Media</a>
        <a href="http://localhost:1313/links/" class="">Links</a>
        <a href="http://localhost:1313/about/" class="">About</a>
  </nav>
</div>
<div id="content">
<div class="article-content"> 
  <h1> An Introduction to the Theory of Cellular Automata </h1>
  <p class="pub-date">Published: January 1, 0001</p>
  
  <p>Outline:</p>
<ul>
<li>Basics of CA
<ul>
<li>What are cellular automata</li>
<li>Why cellular automatata</li>
<li>Definitions</li>
</ul>
</li>
<li>Computability theory and Chomsky hierachy
<ul>
<li>Wireworld</li>
<li>Simulation TUring machine
<ul>
<li>do not show the ufll, only say it is psosible and link sources.</li>
</ul>
</li>
</ul>
</li>
<li>Finite Patterns and Configurations
<ul>
<li>Definitin</li>
<li>Difference CA TM</li>
<li>Use CA to recognize formal languages</li>
</ul>
</li>
<li>Self-reproduction
<ul>
<li>Reproduction of any pattern
<ul>
<li>small Note: you can reproduce TM</li>
</ul>
</li>
</ul>
</li>
<li>Sorting with 1d CA</li>
<li>Signals and Markings</li>
<li>Synchronisation</li>
<li>Sorting in 1d again with the new techniques</li>
<li>Leader Problem</li>
<li>Asycnrhonous and Probabilistic CA</li>
<li>Pile of Sand modell</li>
<li>Simulation of Air in Space station 13
<ul>
<li><a href="https://tomforsyth1000.github.io/papers/cellular_automata_for_physical_modelling.html">https://tomforsyth1000.github.io/papers/cellular_automata_for_physical_modelling.html</a></li>
</ul>
</li>
</ul>
<h2 id="1-basic-of-cellular-automata">1. Basic of Cellular Automata</h2>
<h3 id="11-what-are-cellular-automata">1.1 What are Cellular Automata</h3>
<p>You might have heard of <a href="https://playgameoflife.com/">Conway&rsquo;s Game of Life</a>, though calling it a &ldquo;game&rdquo; is somewhat misleading &ndash; it is more accurately described as a simulation. The Game of Life models the process of life on a grid of arbitrary size, where each square, or &ldquo;tile,&rdquo; can either be colored (alive) or uncolored (dead). The initial pattern of living cells can be set manually or randomized. From there, the simulation follows a set of simple rules that determine whether each cell will live, die, or remain unchanged in the next generation. The process repeats step by step until the user decides to stop it.</p>
<p>It’s called the <em>Game of Life</em> because it mimics biological life, with colored tiles representing living cells and non-colored ones representing dead cells. The rules simulate conditions for survival, birth, or death of these cells.</p>
<p>For more detail, I highly recommend checking out this aweasome <a href="https://youtu.be/R9Plq-D1gEk">Numberphile video</a> with the game’s creator.</p>


<figure>
    <img style="display: block; margin-left: auto; margin-right: auto; width:70%" src="/attachments/game-of-life-loop-cropped.gif">
    <figcaption style="text-align:center; margin-top: 10px;">
        Animation made by Ivan Lokhov.
    </figcaption>
</figure>


<p>While Conway&rsquo;s Game of Life is interesting, as true students of theoretical computer science, the first questions we should asks are: How can we formally describe this process? How can we generalize Conway&rsquo;s Game of Life? These are the topics I&rsquo;d like to explore in this article.</p>
<p>In the broadest terms, cellular automata(CA) are a computational model similar to <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machines</a> and <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machines</a>. In cellular automata, we have a grid of cells, each of which can exist in a finite number of states. At each step, all cells change their state simultaneously according to a predefined set of rules. Like finite state machines and Turing machines, cellular automata can be used to perform certain computations.</p>
<p>To fully understand the concepts presented in this article, it is required to have a basic understanding of the following prerequisites:</p>
<ul>
<li>Fundamentals of formal computer science language (e.g., <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>)</li>
<li>Basics of computability theory (e.g., <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a></li>
</ul>
<p>I will be using some technical jargon throughout this article, so knowing these topics is rather important.</p>
<h3 id="12-why-use-cellular-automata">1.2 Why use Cellular Automata?</h3>
<p>Why should we care about the cellular automata computational model? Theoretical computer science often resembles mathematics in that we explore topics that may not have immediate practical applications, yet we explore them nonetheless. Why? It&rsquo;s the same as to ask why a painter paints, a sculptor sculpts, and a photographer captures images: to try to capture the beauty in front of them, trying to grasp the Platonic ideal of beauty.</p>
<p>While that is a noble pursuit, cellular automata offer more than just that. In traditional computational paradigms, instructions are executed sequentially, one after another. In contrast, cellular automata allow all cells to update simultaneously, leading to significant speedups in solving certain problems. For instance, the fastest general comparison sorting algorithm with a Turing machine operates in \(O(n \log n)\), whereas with cellular automata, we can achieve sorting in \(O(n)\) under specific conditions.</p>
<p>Furthermore, cellular automata are often useful in simulations, particularly in scenarios involving <a href="https://tomforsyth1000.github.io/papers/cellular_automata_for_physical_modelling.html">gases</a> or fluids. For instance, they have been utilized to investigate ways to <a href="https://www.sciencedirect.com/science/article/abs/pii/S0167819100000843">improve the taste of coffee</a> by simulating the brewing process. Another example of cellular automata being used for simulation purposes is the game <a href="https://store.steampowered.com/app/881100/Noita/">Noita</a>, where the entire environment is fully destructible, thanks to its physics engine, which heavily utilizes cellular automata.</p>


<figure style="text-align: center;">
    <video style="display: block; margin-left: auto; margin-right: auto; width:80%" controls muted>
        <source src="/attachments/noita_trailer.webm" type="video/webm">
        Your browser does not support this embedded video.
    </video>
    <figcaption>Trailer of the video game <i>Noita</i>.</figcaption>
</figure>


<h3 id="13-basic-definition">1.3 Basic Definition</h3>
<p><strong>1.3.1 Definition</strong> &ndash;
The <strong>Space</strong> \(R\) of a cellular automata, is defined as \(R = \mathbb{Z}_1 \times ... \times \mathbb{Z}_1\) where we call \(d\) the <strong>dimensionality</strong> of the Space. We can identify a given cell through the usage of <strong>coordiantes</strong> \(i = (i_1, ..., i_d)\). We furthmore have a set of finite states \(Q\). A <strong>global configuration</strong> is defined as \(c : R \to Q\) i.e. each cell gets assigned one state.</p>
<p><strong>1.3.2 Example</strong> &ndash;
Our space is \(R = \mathbb{Z}_1 \times \mathbb{Z}_2\), we have four states \(Q = \{\text{Brown, Black, Beige, Purple}\}\).</p>


<figure>
    <img style="display: block; margin-left: auto; margin-right: auto; width:30%" src="/attachments/ca_example_1.jpg">
</figure>


<p>In the most simple case our turing machine works deterministic, though it can also work asynchronous or probabilistic.</p>
<p><strong>1.3.3 Definition</strong> &ndash;
A <strong>neighborhood</strong>, is a finite set \(N = \{n_1, ..., n_k\} \subset \mathbb{Z}^d\). Where \(\mathbb{Z}^d\) is not the Space \(R\). The neighborhood of a cell \(i\) is \(n(i) := n + i\), this means we can get the \(j\)-th neighbor from the cell () like this \(i + n_j\).
We call the mapping \(l : N \to Q\) a <strong>local configuration</strong> i.e. this describes a possible distribution of states in a neighborhood.</p>
<p><strong>1.3.4 Definition</strong> &ndash;
The <strong>d-dimensional Moore-Neighborhood</strong> with radius \(r\) we call \(M_r^d\) and is defined as \(M_r^d := \{(i_1,...,i_d) | \max_j |i| \leq r \}\).
The <strong>d-dimensional Non-Neuman-Neighborhood</strong> with radius \(r\) ist \(N_r^d = \{(i_1,...,i_d) | \sum |i_j| \leq r\}\).</p>


<figure>
    <img style="display: block; margin-left: auto; margin-right: auto; width:60%" src="/attachments/moore_neighborhood.jpg">
    <img style="display: block; margin-left: auto; margin-right: auto; width:60%" src="/attachments/von_neumann_neighborhood.jpg">
    <figcaption style="text-align:center; margin-top: 10px;">
        An example of the Moore and Von-Neumann Neighborhood.
    </figcaption>
</figure>


<p><strong>1.3.5 Definition</strong> &ndash;
How a <em>deterministic</em> cellular automata works, is defined through the <strong>local transfer function</strong> \(\sigma: Q^N \to Q\) i.e. this mapping assigns a cell based, on the state of its neighbors, a new state.</p>
<p><strong>1.3.6 Definition</strong> &ndash;
If we have a global configuration \(c\), then we call the mapping \(c_{i + N} : N \to Q, n \mapsto c_{i+n}\) the <strong>local configuration at i in c</strong> i.e. \(c_{i + N}\) gives you for every neighbor for the cell i in the configuration c, its state \(c_{i + n}\). (Notice \(n\) is not \(N\)).</p>
<p><strong>1.3.7 Definition</strong> &ndash;
The <strong>global transfer function</strong> is defined as \(\Delta : Q^R \to Q^R \) with \(\Delta(c)_i = \sigma(c_{i + N})\) i.e. this function assign each cell its new state.</p>
<p>This CA is now strictly synchronous, because in each step all cell switch their state at the same time, like defined through the global transfer function.</p>
<p><strong>1.3.8 Example</strong> &ndash;
Now that we have introduced the basic concepts of the formal language of cellular automata (CA), we can return to Conway&rsquo;s Game of Life and examine how it is defined.</p>
<p>In Conway&rsquo;s Game of Life, we have the following parameters for the cellular automaton:</p>
<ul>
<li><strong>Space:</strong> \( R = \mathbb{Z}^2 \) (the two-dimensional grid of cells)</li>
<li><strong>Neighborhood:</strong> \( N = M_{1}^2 \) (the adjacent cells)</li>
<li><strong>States:</strong> \( Q = \{0, 1\} \) (where 0 represents a dead cell and 1 represents a live cell)</li>
</ul>
<p>The local transition function is defined as follows:</p>
$$
\sigma(l) = 
\begin{cases}
      1, & \text{if } l(0,0) = 0 \land s(l) = 3 \\
      1, & \text{if } l(0,0) = 1 \land 2 \leq s(l) \leq 3 \\
      0, & \text{otherwise}
\end{cases}
$$<p>Here, the helper function \( s(l) = \sum_{n \in N, n \neq (0,0)} l(n) \) counts the number of alive neighbors around the cell at \( (0, 0) \).</p>
<ul>
<li>The <strong>first case</strong> states that if a cell is dead (i.e., \( l(0,0) = 0 \)) and has exactly 3 alive neighbors, it becomes alive again.</li>
<li>The <strong>second case</strong> indicates that if a cell is alive (i.e., \( l(0,0) = 1 \)) and has between 2 and 3 alive neighbors, it remains alive.</li>
<li>The <strong>third case</strong> specifies that if an alive cell has more than 3 alive neighbors, it dies due to overcrowding.</li>
</ul>
<p>For more information about Conway&rsquo;s Game of Life, including specific patterns that emerge, check out the <a href="http://www.radicaleye.com/lifepage/">following blog post</a>.</p>
<h2 id="2-computability-theory-of-cellular-automata">2. Computability Theory of Cellular Automata</h2>
<hr>
<p>References:</p>
<ul>
<li>This article is based on the lecture &ldquo;Algorithms in Cellular Automata&rdquo; by Thomas Worsch</li>
</ul>
 
</div>

    </div><div class="footer">
  Made with <a href="https://gohugo.io/">Hugo</a>, website licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.
</div>
</body>
</html>
